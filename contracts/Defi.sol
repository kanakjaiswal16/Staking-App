// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "@openzeppelin/contracts/token/ERC20/ERC20.sol";

contract CustomToken is ERC20 {
    constructor(
        string memory name,
        string memory symbol,
        uint256 totalSupply,
        address owner
    ) ERC20(name, symbol) {
        _mint(owner, totalSupply);
    }
}

contract DeFi {
    struct Token {
        address tokenAddress;
        string name;
        string symbol;
        uint256 totalSupply;
        address owner;
    }

    address public owner;
    bool public Staking;

    constructor() {
        owner = msg.sender;
        Staking = true;
    }

    //for retriving Token info from Token address
    mapping(address => Token) public tokens;
    //if token exit or not
    mapping(address => bool) public isToken;
    //check how many tokens a particular person has minted
    mapping(address => address[]) private checkOwnerToken;
    mapping(address => mapping(address => uint256)) public stakeAmount;
    mapping(address => mapping(address => uint256)) public TimeStamp;

    event TokenMinted(
        address tokenAddress,
        string name,
        string symbol,
        uint256 totalSupply,
        address owner
    );

    event StakeSuccess(address tokenAddress, uint256 amount, uint256 timestamp);
    event unstakesuccess(
        address tokenAddress,
        uint256 amount,
        uint256 timestamp,
        uint256 reward
    );

    function mintToken(
        string memory name,
        string memory symbol,
        uint256 totalSupply
    ) external {
        CustomToken token = new CustomToken(
            name,
            symbol,
            totalSupply,
            msg.sender
        );

        Token memory newToken = Token({
            tokenAddress: address(token),
            name: name,
            symbol: symbol,
            totalSupply: totalSupply / 1e18,
            owner: msg.sender
        });

        tokens[address(token)] = newToken;
        isToken[address(token)] = true;
        checkOwnerToken[msg.sender].push(address(token));

        emit TokenMinted(
            address(token),
            name,
            symbol,
            totalSupply / 1e18,
            msg.sender
        );
    }

    //to return Token addresses generated by a particular address
    function OwnerToken(address x) public view returns (address[] memory) {
        address[] memory tempaddresses = new address[](
            checkOwnerToken[x].length
        );
        for (uint256 i = 0; i < checkOwnerToken[x].length; i++) {
            tempaddresses[i] = checkOwnerToken[x][i];
        }

        return tempaddresses;
    }

    function stake(address tAddress, uint amount) public {
        require(Staking == true, "paused");
        require(amount > 0, "Can't be zero");
        uint balance = ERC20(tAddress).balanceOf(msg.sender);
        require(amount <= balance, "Not enough token");
        stakeAmount[msg.sender][tAddress] += amount;
        TimeStamp[msg.sender][tAddress] = block.timestamp;
        CustomToken token = CustomToken(tAddress);
        token.transferFrom(msg.sender, address(this), amount);
        emit StakeSuccess(tAddress, amount, TimeStamp[msg.sender][tAddress]);
    }

    // function checkStakeAmount

    function unstake(address tAddress, uint256 amount) public {
        require(Staking == true, "paused");
        require(amount > 0, "Can't be zero");
        require(
            amount <= stakeAmount[msg.sender][tAddress],
            "Don't have enoungh tokens"
        );
        uint256 totalTime = block.timestamp - TimeStamp[msg.sender][tAddress];
        uint256 totalReward = rewards(totalTime, amount);
        stakeAmount[msg.sender][tAddress] -= amount;
        TimeStamp[msg.sender][tAddress] = block.timestamp;
        ERC20(tAddress).transfer(msg.sender, amount + totalReward);
        emit unstakesuccess(
            tAddress,
            amount,
            TimeStamp[msg.sender][tAddress],
            totalReward
        );
    }

    function rewards(
        uint256 totalTime,
        uint256 amount
    ) public pure returns (uint256) {
        // For each day of staking, the user will get 0.1% of the reward
        uint256 rewardPercentage = 1;
        uint256 totalDays = totalTime / 86400;
        uint256 reward = (amount * totalDays * rewardPercentage) / 1000;
        return reward;
    }

    function getTokenBalance(address tAddress) public view returns (uint256) {
        uint256 balance = ERC20(tAddress).balanceOf(msg.sender);
        return balance;
    }

    function stopStaking() public onlyOwner {
        Staking = false;
    }

    function startStaking() public onlyOwner {
        Staking = true;
    }

    function Owner() public view onlyOwner returns (bool) {
        return true;
    }

    modifier onlyOwner() {
        require(msg.sender == owner, "OnlyOwner");
        _;
    }
}
